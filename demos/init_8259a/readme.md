# 梳理linux0.12知识点系列 
# 之
# 8259A的初始化和时钟中断

## 背景

	cpu和设备协同工作的高效方式是使用中断机制，本例子机遇之前的打
	开了A20地址线之后的demo，进一步初始化了8259A终端控制芯片，并
	且屏蔽了除了始终中断以外的所有硬件中断。当始终中断发生时，在
	屏幕上打印'T' 'I' 'M' 'E' 'R'五个字符

## 额外修改

	除了加入初始化8259A芯片和增加中断处理函数的逻辑之外，本例子
	将gcc和ld的处理方式修改为32位模式，并且makefile中去掉二进制
	头的操作修改了偏移量。这是因为我们会从linux0.12的system.h代
	码中扣出几个嵌入汇编的宏来使用，这几个嵌入汇编如果默认用64位的
	模式编译的话生成的二进制是错误的

### 修改细节
	
* makefile中
	
`dd if=lan_os of=a.img bs=512 count=17 skip=8 seek=1 conv=notrunc`
skip=4096变成了skip=8

ld 加入了 `-m elf_i386` 选项

gcc 加入了 `-m32` 选项

* head.s中
	
write_char取传入参数不再从edi寄存器去，而是从`[esp+16]`这个地址取

`mov eax, [esp+16]`

## cpu于8259A的连接方式

	(笔者解读)从下图可以看到主板上的物理连接关系，每片8259A有8根输入线，可以连接8个硬件设备
	
	拿时钟为例简单描述一下8259A和cpu常见的工作流程
	
	1.在机器上电初始化的时候我们对时钟芯片进行变成，命令它在震动一个固定次数后要给cpu发送信号
	2.cpu在运行的时候是不断的取指令，执行指令的
	3.当始终芯片到了固定的次数时，它不能直接给cpu的intr引脚发指令，为什么呢，因为如果这么设计
	  cpu就只能够接收时钟的消息而不能处理其他硬件的消息了，很显然我们要处理多种硬件才能使用计
	  算机
	4.这时候我们需要一个代理人帮我们接收各种硬件的消息，并且有一种机制通知cpu：1）有人发消息
	  给你了 2）这个人是某某某。 做这件事情的这个代理人就是8259A芯片
	5.一块8259A芯片可以连接8个设备，8259A在自己收到消息后通知cpu的intr引脚，cpu在执行完
	  当前的最后一条指令后去问8259A是谁发送的中断请求，这时8259A会把中断对应的中断号放在
	  数据总线上，cpu通过这个中断号查找自己的IDT表，找到中断处理函数并执行。
	6.这里我们能看到8259A的几个功能
		1）能够将自己的一个输入引脚对应到一个中断号
		2）必须考虑多个中断同时到达的情况，所以8259A可以对不同的中断有优先级处理和排队的能力
		3）8259A实际上还有能力屏蔽某个引脚的中断（这是显而易见的），在汇编代码中的实现方式就是
		   给8259A的一个io端口发送一个控制命令字，这个字节是一个掩码，只用对应位置是0，该中断
		   才能被转发给cpu的intr引脚
		4）如下面第一幅图所示，8259A是可以串联的，这样可以控制15个硬件
	 
	
		
以下内容摘自《ORANGE'S:一个操作系统的实现》
	
![](https://raw.githubusercontent.com/freelw/LanOS/master/demos/pic/orange1.png)

    中断产生的原因有两种，一种是外部中断，也就是由硬件产生的中断，
    另一种是由指令int n产生的中断。指令int n产生中断时的情形
    如图3.37所示，n即为向量号，它类似于调用门的使用。外部中断的情况
    则复杂一些，因为需要建立硬件中断与向量号之间的对应关系。外部中断
    分为不可屏蔽中断（NMI）和可屏蔽中断两种，分别由CPU的两根引脚NMI
    和INTR来接收，如图3.39所示。

![](https://raw.githubusercontent.com/freelw/LanOS/master/demos/pic/orange2.png)

	NMI不可屏蔽，因为它与IF是否被设置无关。NMI中断对应的中断向量号为2
	，这在表3.8中已经有所说明。可屏蔽中断与CPU的关系是通过对可编程中断
	控制器8259A建立起来的。如果你是第一次听说8259A，那么你可以认为它是
	中断机制中所有外围设备的一个代理，这个代理不但可以根据优先级在同时
	发生中断的设备中选择应该处

