# 真·三十天
## 保护模式速成

### 要讲解的重点

* 什么是boot 什么是header
* 为什么要有保护模式


### 我们的近期目标

上一个视频为大家介绍了二进制文件相关的知识和工具

也介绍了裸机在启动后大概经历的过程

然后演示了一下汇编语言和c语言互相调用的套路

在视频的最后我推荐大家去看一下《源码》第四章及之前的部分

这期我们先设定一个小目标，就是我们要用c语言来改写《源码》第四章的demo

有了这个有一些难度，但是看起来不算太难的小目标，我们在学习的时候就会有方向，不至于在纷杂的代码中迷失

这期的开头我先带大家来看一下《源码》第四章讲了一些什么东西

我们直取要害，先跳过知识点部分，直接看demo效果，然后看代码

之后我们在梳理一下为了达成这个小目标，我们要经历的过程，和要学习的知识点

（演示github链接）

---

（跳到pdf的134页）

这个demo的功能就是手动构建两个符合TSS规范的任务，这个TSS（Task state segment）会在之后详细说明一下
系统不断的切换这两个任务
这两个任务不断做自己的工作，也就是调用系统的功能在屏幕上一个打印A，另一个打印B

大体看一下它的两个汇编文件

分别是boot和head

复习一下上个视频的知识

boot就是512字节的引导扇区

head就是要加载到0地址的代码，所以才叫head，头部

那看一下书中的这两个文件代码风格差异非常大

原因是在编写linux0.12的时候，没有一个能够同时支持16位和32位代码的汇编器

所以linus用as86来编译16位代码，用gas来编译32位代码

而在我们的系统中，统一使用nasm来编译代码，所以汇编的风格是一致的

这里面有一个细节上个视频没有说，就是这512字节是如何把head中的代码折腾到0地址处的

本次我们也好好分析一下这个扇区的功能

那下面我们以自己的代码为例说明

---

(对照 pdf 131页的图来说明)

首先看磁盘布局的图，看makefile

解释一下vfd文件大小的由来（在questions.md 中bios int 0x13)

说明一下为什么不直接挪动到0地址处（bios 中断向量表）

---

### 疑点

jmp dword 8:0 是什么

这里我们先看一下当前的寻址方式

我们知道启动的时候是跑在16位的代码中的

这个16位具体体现着什么方面呢

就是我们的所有寄存器里面都只能装最大2^16这么大的数字

而早期cpu是有20根地址线的，最大能使用的内存是1M，靠一个寄存器是无法完全覆盖的

因为差了4位

所以有段寄存器这种东西

包括 cs ds es gs fs ss

我们用一个段寄存器里面的值和另一个寄存器里面的值组合在一起形成一个地址来访问内存

组合的规则是段寄存器里面的值左移4位再加上另外一个寄存器的值

拿boot.s 11行开始的es:bx举例（bios的简单说明在pdf 135页代码18行开始）

再看开头 jmp 7c0h

所以一个地址可以有多种表示方式
比如 0x102c

可以是0:0x102c 0x100:0x2c 0x102:0xc

---